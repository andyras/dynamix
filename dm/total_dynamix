#!/bin/bash
#$ -S /bin/bash
#$ -cwd
#$ -V

# set up the proper environment variables for a PBS job.
#PBS -V
#PBS -o stdout.log
#PBS -e stderr.log
##PBS -o /dev/null
##PBS -e /dev/null
#PBS -l mem=5gb

if [ ${HOSTNAME} == "tim.selfip.org" ]; then
 # go to directory from which job was submitted.  If this job is being run
 # (not submitted to a queue) this should not run.
 if [ ! -z ${PBS_O_WORKDIR} ]; then
  echo "going to PBS working directory: ${PBS_O_WORKDIR}"
  cd ${PBS_O_WORKDIR}
 fi
fi

## INPUT PARAMETERS ##
. ./ins/parameters.in

function compile {
## COMPILE ##
 echo "### $(date) compiling dynamix.cpp..."
 CPP=g++
 # check if better compilers are installed
 which g++-4.7.0 &> /dev/null
 if [ $? == 0 ] ; then CPP=g++-4.7.0 ; fi
 which g++-4.7.1 &> /dev/null
 if [ $? == 0 ] ; then CPP=g++-4.7.1 ; fi
 which g++-4.7.2 &> /dev/null
 if [ $? == 0 ] ; then CPP=g++-4.7.2 ; fi
 which icpc &> /dev/null
 if [ $? == 0 ] ; then CPP=icpc ; fi
 cd build
 make -j 12 CPP=$CPP
 if [ $? == 0 ] ; then
  echo "### $(date) done compiling!" && make install
  cd ..
 else
  echo "### $(date) failed to compile :("
  exit
 fi
}

function compile_serial {
 export OMP_NUM_THREADS=1
 export MKL_NUM_THREADS=1
 export MKL_DOMAIN_NUM_THREADS=1
 cd build
 make clean
 cd - &> /dev/null
 compile
}

function compile_parallel {
 export OMP_NUM_THREADS=
 export MKL_NUM_THREADS=
 export MKL_DOMAIN_NUM_THREADS=
 cd build
 make clean
 cd - &> /dev/null
 compile
}

function run {
## RUN THE PROGRAM! ##
 module load intel
 module load cvode/debug-2.7.0
 echo "### $(date) running dynamix..."
 ./bin/dynamix
 if [ $? == 0 ] ; then
  echo "### $(date) dynamix done!"
 else
  echo "### $(date) dynamix did not run :("
  exit
 fi
 mkdir -p outs
 rm -f outs/*
 mv *.out outs/
 mkdir -p figures
 chmod 755 *.plt
 mv *.plt figures/
}

function movie_maker {
 ## GENERATE MOVIE MAKER ##
 timestep=$(echo "scale=4; ($tout/$numOutputSteps/41.34)" | bc)
 echo "### $(date) making movie maker..."
 sed 's/[^ ]* \(.*\)/\1/' outs/kprobs.out > temp1.out	# strip first column (times) from kprobs.out
 sed 's/[^ ]* \(.*\)/\1/' outs/cprobs.out > temp2.out	# strip first column (times) from cprobs.out
 sed 's/[^ ]* \(.*\)/\1/' outs/bprobs.out > temp3.out	# strip first column (times) from bprobs.out
 paste -d " " temp1.out temp2.out temp3.out > temp4.out
 cat outs/energy.out temp4.out > temp.out
 cat temp.out | awk 'BEGIN {FS=" "}{for (i=1;i<=NF;i++){ arr[NR,i]=$i; if(big <= NF) big=NF; }} END { for (i=1;i<=big;i++) { for(j=1;j<=NR;j++) { printf("%s\t",arr[j,i]); } printf("\n"); }}' > transpose.out
 
 max_pop=$(python2 tools/findMaxZ.py outs/kprobs_gnuplot.out)
 max_pop=$(echo "scale=4; ($max_pop*1.1)" | bc)
 
 echo "set term png truecolor size 800,800 font 'Arial-Bold,14'
set xtics scale 0
unset key" > figures/movie.plt

 xtics_string="nomirror scale 0,-1 ("	# starts the xtics string
 for (( i=0 ; i<=$tout ; i+=1000 ))	# builds the xtics string
 do
  time_au=$i
  time_fs=$(echo "scale=4; ($i/41.3414)" | bc)
  time_x=$time_au	# make this line reflect the units you want in the plot
  xtics_string=$xtics_string"\"$time_x\" $i, "
 done

 #for (( i=0; i<=$numOutputSteps; i++ ))
 for (( i=500; i<=515; i++ ))	# for testing movie making
 do
  time_fs=$(echo "scale=4; ($i*$tout/$numOutputSteps/41.3414)" | bc)
  time_au=$(echo "scale=4; ($i*$tout/$numOutputSteps)" | bc)
  time_n=$(echo "scale=4; ($time_au/$tout)" | bc)
  time_x=$time_au	# make this line reflect the units you want in the plot
  time_unit="a.u."	# make this line reflect the units you want in the plot
  foo=$(printf "%07d" $(($i)))
  xtix=$xtics_string"\"\" $time_x 1)"	# terminates the xtics string
  echo "set output \"img/${foo}.png\"
set multiplot

set origin 0,0
set size 1.1,0.5
set border 0
set ytics scale 0
set ylabel \"Energy above band edge \(a.u.\)\"
set xlabel \"Time \($time_unit\)\"
set xrange [0:$tout]
set yrange [$k_bandedge:$k_bandtop]
unset colorbox
set pm3d map
set palette model XYZ functions gray**0.45, gray**1.0, gray**1.0
set arrow 1 from graph $time_n, graph -0.03 to graph $time_n, graph -0.01 nohead lw 3
set arrow 2 from graph $time_n, graph 1.01 to graph $time_n, graph 0.98 nohead lw 3
splot './outs/kprobs_gnuplot.out'
unset arrow

set origin 0,0.5
set size 1,0.5
set border 15
set ytics scale 1 nomirror
set xlabel \"Energy above band edge \(a.u.\)\"
set ylabel \"Electron probability\"
set title \"Bulk populations at time = $time_x $time_unit\"
plot [$k_bandedge:$k_bandtop] [0:$max_pop] '../transpose.out' every ::::$((Nk-1)) using 1:$((i+2)) with filledcurve x1
unset title

unset multiplot" >> figures/movie.plt
 done
 echo "### $(date) done making movie maker!"
}


function movie {
 ## MAKE MOVIE ##
 echo "### $(date) making .png for each frame of the movie..."
 mkdir -p img
 rm -rf img/*
 gnuplot figures/movie.plt && echo "### $(date) done making .pngs!"
 echo "### $(date) making movie..."
 mencoder -really-quiet -ovc lavc -lavcopts vcodec=msmpeg4v2:vpass=1:$opt -mf type=png:fps=25 -nosound -o /dev/null mf://img/\*.png
 mencoder -really-quiet -ovc lavc -lavcopts vcodec=msmpeg4v2:vpass=1:$opt -mf type=png:fps=25 -nosound -o bulk_states.avi mf://img/\*.png
 echo "### $(date) done\! movie is bulk_states.avi"
 rm -rf img
 [ $do_fullcleanup == 1 ] && rm -f figures/movie.plt
 [ $do_cleanup == 1 ] && rm -f divx2pass.log
 [ $do_cleanup == 1 ] && rm -f temp*.out
 [ $do_cleanup == 1 ] && rm -f transpose.out
}


function backup {
## BACK UP FILES ##
 echo "### $(date) backing things up..."
 durr=backup/dynamix_$(date +%F.%H.%M.%S)
 mkdir -p $durr
 cp -rf ins/ outs/ bin/ figures/ doc/ total_dynamix $durr
 [ $do_plot == 1 ] && cp *.eps $durr
 [ $do_movie == 1 ] && cp bulk_states.avi $durr
 [ $(($Nb)) == 0 ] && rm -f $durr/outs/tbprob.out $durr/outs/Ibprob.out $durr/outs/bmax.out && ls $durr
 echo "### $(date) all backed up\!"
}

### This is where the script actually starts doing things. ###

Nb=$(wc -l "ins/b_energies.in" | awk '{print $1}')
mkdir -p figures

echo "### $(date) dynamix run starting now..."
echo "###"
echo "###"

[ $do_compile_serial == 1 ] && compile_serial
[ $do_compile_parallel == 1 ] && compile_parallel
[ $do_compile == 1 ] && compile
[ $do_run == 1 ] && run
[ $make_movie_maker == 1 ] && movie_maker
[ $do_movie == 1 ] && movie
[ $do_backup == 1 ] && backup

echo "### $(date) all done!"
echo "###"
echo "###"
